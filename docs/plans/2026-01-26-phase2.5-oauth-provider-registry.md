# Phase 2.5: OAuth Auth & Provider Registry Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add OAuth authentication for Claude subscription users and refactor LLM providers to use a registry pattern for extensibility.

**Architecture:** OAuth flow opens browser for user consent, receives token via local callback server, stores in ~/.owliabot/auth.json with auto-refresh. Provider registry decouples runner from specific implementations.

**Tech Stack:** Node.js http (OAuth callback), open (browser launch), existing fetch for API calls

---

## Task 1: Install open dependency

**Files:**
- Modify: `package.json`

**Step 1: Install open package**

```bash
npm install open
```

**Step 2: Verify installation**

```bash
npm ls open && npm run build
```

**Step 3: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: add open dependency for browser launch"
```

---

## Task 2: Provider Registry

**Files:**
- Create: `src/agent/providers/registry.ts`

**Step 1: Create provider registry**

```typescript
/**
 * LLM Provider Registry
 * @see design.md DR-008
 */

import { createLogger } from "../../utils/logger.js";
import type { Message } from "../session.js";
import type { LLMResponse, CallOptions, LLMProvider } from "../runner.js";

const log = createLogger("provider-registry");

export type ProviderCallFn = (
  config: LLMProvider,
  messages: Message[],
  options?: CallOptions
) => Promise<LLMResponse>;

export class ProviderRegistry {
  private providers = new Map<string, ProviderCallFn>();

  register(id: string, fn: ProviderCallFn): void {
    if (this.providers.has(id)) {
      log.warn(`Provider ${id} already registered, replacing...`);
    }
    this.providers.set(id, fn);
    log.info(`Registered provider: ${id}`);
  }

  get(id: string): ProviderCallFn | undefined {
    return this.providers.get(id);
  }

  has(id: string): boolean {
    return this.providers.has(id);
  }

  list(): string[] {
    return Array.from(this.providers.keys());
  }
}

// Global singleton
export const providerRegistry = new ProviderRegistry();
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/agent/providers/registry.ts
git commit -m "feat(providers): add provider registry"
```

---

## Task 3: Refactor Anthropic Provider to Register

**Files:**
- Modify: `src/agent/providers/anthropic.ts`
- Modify: `src/agent/providers/index.ts`

**Step 1: Update anthropic.ts to register itself**

Add at the end of `src/agent/providers/anthropic.ts`:

```typescript
import { providerRegistry } from "./registry.js";

// Register provider
providerRegistry.register("anthropic", async (config, messages, options) => {
  return callAnthropic(
    { apiKey: config.apiKey, model: config.model },
    messages,
    options
  );
});
```

**Step 2: Update index.ts to export registry and trigger registration**

Replace `src/agent/providers/index.ts` content:

```typescript
// Re-export registry
export { providerRegistry, type ProviderCallFn } from "./registry.js";

// Import providers to trigger registration
import "./anthropic.js";
```

**Step 3: Verify build**

```bash
npm run build
```

**Step 4: Commit**

```bash
git add src/agent/providers/anthropic.ts src/agent/providers/index.ts
git commit -m "feat(anthropic): register provider with registry"
```

---

## Task 4: Refactor Runner to Use Registry

**Files:**
- Modify: `src/agent/runner.ts`

**Step 1: Update runner to use registry**

Replace the `callProvider` function and add import:

```typescript
// Add import at top
import { providerRegistry } from "./providers/index.js";

// Replace callProvider function
async function callProvider(
  provider: LLMProvider,
  messages: Message[],
  options?: CallOptions
): Promise<LLMResponse> {
  const callFn = providerRegistry.get(provider.id);

  if (!callFn) {
    throw new Error(`Unknown provider: ${provider.id}. Available: ${providerRegistry.list().join(", ")}`);
  }

  return callFn(provider, messages, options);
}
```

Also remove the direct import of `callAnthropic` since it's now handled by registry.

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/agent/runner.ts
git commit -m "refactor(runner): use provider registry instead of switch"
```

---

## Task 5: Auth Token Store

**Files:**
- Create: `src/auth/store.ts`

**Step 1: Create token store**

```typescript
/**
 * Auth token storage
 * @see design.md DR-007
 */

import { readFile, writeFile, mkdir } from "node:fs/promises";
import { dirname, join } from "node:path";
import { createLogger } from "../utils/logger.js";

const log = createLogger("auth-store");

export interface AuthToken {
  accessToken: string;
  refreshToken: string;
  expiresAt: number; // Unix timestamp in ms
  tokenType: string;
}

export interface AuthStore {
  get(): Promise<AuthToken | null>;
  save(token: AuthToken): Promise<void>;
  clear(): Promise<void>;
  isExpired(token: AuthToken): boolean;
  needsRefresh(token: AuthToken): boolean;
}

export function createAuthStore(authDir: string): AuthStore {
  const authPath = join(authDir, "auth.json");

  return {
    async get(): Promise<AuthToken | null> {
      try {
        const content = await readFile(authPath, "utf-8");
        return JSON.parse(content) as AuthToken;
      } catch (err) {
        if ((err as NodeJS.ErrnoException).code === "ENOENT") {
          return null;
        }
        throw err;
      }
    },

    async save(token: AuthToken): Promise<void> {
      await mkdir(dirname(authPath), { recursive: true });
      await writeFile(authPath, JSON.stringify(token, null, 2));
      log.info("Auth token saved");
    },

    async clear(): Promise<void> {
      try {
        await writeFile(authPath, "");
        log.info("Auth token cleared");
      } catch (err) {
        if ((err as NodeJS.ErrnoException).code !== "ENOENT") {
          throw err;
        }
      }
    },

    isExpired(token: AuthToken): boolean {
      return Date.now() >= token.expiresAt;
    },

    needsRefresh(token: AuthToken): boolean {
      // Refresh 5 minutes before expiry
      const refreshBuffer = 5 * 60 * 1000;
      return Date.now() >= token.expiresAt - refreshBuffer;
    },
  };
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/auth/store.ts
git commit -m "feat(auth): add token store"
```

---

## Task 6: OAuth Flow

**Files:**
- Create: `src/auth/oauth.ts`

**Step 1: Create OAuth flow**

```typescript
/**
 * OAuth flow for Claude subscription
 * @see design.md DR-007
 */

import { createServer } from "node:http";
import { URL } from "node:url";
import open from "open";
import { createLogger } from "../utils/logger.js";
import type { AuthToken, AuthStore } from "./store.js";

const log = createLogger("oauth");

// Claude OAuth endpoints (same as Claude CLI)
const OAUTH_AUTHORIZE_URL = "https://claude.ai/oauth/authorize";
const OAUTH_TOKEN_URL = "https://claude.ai/oauth/token";
const CLIENT_ID = "owliabot";
const REDIRECT_PORT = 19275;
const REDIRECT_URI = `http://localhost:${REDIRECT_PORT}/callback`;

export interface OAuthOptions {
  store: AuthStore;
}

export async function startOAuthFlow(options: OAuthOptions): Promise<AuthToken> {
  const { store } = options;

  // Generate state for CSRF protection
  const state = generateRandomString(32);

  // Build authorization URL
  const authUrl = new URL(OAUTH_AUTHORIZE_URL);
  authUrl.searchParams.set("client_id", CLIENT_ID);
  authUrl.searchParams.set("redirect_uri", REDIRECT_URI);
  authUrl.searchParams.set("response_type", "code");
  authUrl.searchParams.set("state", state);
  authUrl.searchParams.set("scope", "messages:write");

  // Start local server to receive callback
  const code = await waitForCallback(state);

  // Exchange code for token
  const token = await exchangeCodeForToken(code);

  // Save token
  await store.save(token);

  return token;
}

async function waitForCallback(expectedState: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const server = createServer((req, res) => {
      const url = new URL(req.url ?? "", `http://localhost:${REDIRECT_PORT}`);

      if (url.pathname !== "/callback") {
        res.writeHead(404);
        res.end("Not found");
        return;
      }

      const code = url.searchParams.get("code");
      const state = url.searchParams.get("state");
      const error = url.searchParams.get("error");

      if (error) {
        res.writeHead(400);
        res.end(`Authentication failed: ${error}`);
        server.close();
        reject(new Error(`OAuth error: ${error}`));
        return;
      }

      if (state !== expectedState) {
        res.writeHead(400);
        res.end("Invalid state parameter");
        server.close();
        reject(new Error("Invalid OAuth state"));
        return;
      }

      if (!code) {
        res.writeHead(400);
        res.end("Missing authorization code");
        server.close();
        reject(new Error("Missing authorization code"));
        return;
      }

      res.writeHead(200, { "Content-Type": "text/html" });
      res.end(`
        <html>
          <body style="font-family: system-ui; text-align: center; padding: 50px;">
            <h1>Authentication Successful!</h1>
            <p>You can close this window and return to the terminal.</p>
          </body>
        </html>
      `);

      server.close();
      resolve(code);
    });

    server.listen(REDIRECT_PORT, () => {
      log.info(`OAuth callback server listening on port ${REDIRECT_PORT}`);
      log.info("Opening browser for authentication...");

      const authUrl = new URL(OAUTH_AUTHORIZE_URL);
      authUrl.searchParams.set("client_id", CLIENT_ID);
      authUrl.searchParams.set("redirect_uri", REDIRECT_URI);
      authUrl.searchParams.set("response_type", "code");
      authUrl.searchParams.set("state", expectedState);
      authUrl.searchParams.set("scope", "messages:write");

      open(authUrl.toString());
    });

    // Timeout after 5 minutes
    setTimeout(() => {
      server.close();
      reject(new Error("OAuth timeout - no callback received"));
    }, 5 * 60 * 1000);
  });
}

async function exchangeCodeForToken(code: string): Promise<AuthToken> {
  const response = await fetch(OAUTH_TOKEN_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({
      grant_type: "authorization_code",
      code,
      redirect_uri: REDIRECT_URI,
      client_id: CLIENT_ID,
    }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`Token exchange failed: ${response.status} ${text}`);
  }

  const data = (await response.json()) as {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
  };

  return {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    expiresAt: Date.now() + data.expires_in * 1000,
    tokenType: data.token_type,
  };
}

export async function refreshToken(
  token: AuthToken,
  store: AuthStore
): Promise<AuthToken> {
  log.info("Refreshing OAuth token...");

  const response = await fetch(OAUTH_TOKEN_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({
      grant_type: "refresh_token",
      refresh_token: token.refreshToken,
      client_id: CLIENT_ID,
    }),
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`Token refresh failed: ${response.status} ${text}`);
  }

  const data = (await response.json()) as {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
  };

  const newToken: AuthToken = {
    accessToken: data.access_token,
    refreshToken: data.refresh_token,
    expiresAt: Date.now() + data.expires_in * 1000,
    tokenType: data.token_type,
  };

  await store.save(newToken);
  log.info("Token refreshed successfully");

  return newToken;
}

function generateRandomString(length: number): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  const randomValues = new Uint8Array(length);
  crypto.getRandomValues(randomValues);
  for (let i = 0; i < length; i++) {
    result += chars[randomValues[i] % chars.length];
  }
  return result;
}
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/auth/oauth.ts
git commit -m "feat(auth): add OAuth flow"
```

---

## Task 7: Auth Setup Command

**Files:**
- Modify: `src/entry.ts`

**Step 1: Add auth command**

Add imports at top of entry.ts:

```typescript
import { join } from "node:path";
import { createAuthStore } from "./auth/store.js";
import { startOAuthFlow } from "./auth/oauth.js";
```

Add new command before `program.parse()`:

```typescript
program
  .command("auth")
  .description("Manage authentication")
  .command("setup")
  .description("Setup OAuth authentication with Claude")
  .action(async () => {
    try {
      const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? ".";
      const authDir = join(homeDir, ".owliabot");
      const store = createAuthStore(authDir);

      log.info("Starting OAuth setup...");
      const token = await startOAuthFlow({ store });
      log.info("Authentication successful!");
      log.info(`Token expires at: ${new Date(token.expiresAt).toISOString()}`);
    } catch (err) {
      log.error("Authentication failed", err);
      process.exit(1);
    }
  });

program
  .command("auth")
  .command("status")
  .description("Check authentication status")
  .action(async () => {
    const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? ".";
    const authDir = join(homeDir, ".owliabot");
    const store = createAuthStore(authDir);

    const token = await store.get();
    if (!token) {
      log.info("Not authenticated. Run 'owliabot auth setup' to authenticate.");
      return;
    }

    if (store.isExpired(token)) {
      log.info("Token expired. Run 'owliabot auth setup' to re-authenticate.");
    } else if (store.needsRefresh(token)) {
      log.info("Token will expire soon, will be refreshed automatically.");
      log.info(`Expires at: ${new Date(token.expiresAt).toISOString()}`);
    } else {
      log.info("Authenticated");
      log.info(`Token expires at: ${new Date(token.expiresAt).toISOString()}`);
    }
  });

program
  .command("auth")
  .command("logout")
  .description("Clear stored authentication")
  .action(async () => {
    const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? ".";
    const authDir = join(homeDir, ".owliabot");
    const store = createAuthStore(authDir);
    await store.clear();
    log.info("Logged out successfully");
  });
```

**Step 2: Verify build**

```bash
npm run build
```

**Step 3: Commit**

```bash
git add src/entry.ts
git commit -m "feat(cli): add auth setup/status/logout commands"
```

---

## Task 8: OAuth Provider (claude-oauth)

**Files:**
- Create: `src/agent/providers/claude-oauth.ts`

**Step 1: Create OAuth-based Claude provider**

```typescript
/**
 * Claude provider using OAuth token
 * @see design.md DR-007
 */

import { createLogger } from "../../utils/logger.js";
import type { Message } from "../session.js";
import type { LLMResponse, CallOptions, LLMProvider } from "../runner.js";
import type { ToolCall } from "../tools/interface.js";
import { HTTPError } from "../runner.js";
import { providerRegistry } from "./registry.js";
import { createAuthStore, type AuthStore, type AuthToken } from "../../auth/store.js";
import { refreshToken } from "../../auth/oauth.js";
import { join } from "node:path";

const log = createLogger("claude-oauth");

const CLAUDE_API_URL = "https://api.claude.ai/v1/messages";

let authStore: AuthStore | null = null;

function getAuthStore(): AuthStore {
  if (!authStore) {
    const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? ".";
    authStore = createAuthStore(join(homeDir, ".owliabot"));
  }
  return authStore;
}

async function getValidToken(): Promise<AuthToken> {
  const store = getAuthStore();
  const token = await store.get();

  if (!token) {
    throw new Error("Not authenticated. Run 'owliabot auth setup' first.");
  }

  if (store.isExpired(token)) {
    throw new Error("Token expired. Run 'owliabot auth setup' to re-authenticate.");
  }

  if (store.needsRefresh(token)) {
    return await refreshToken(token, store);
  }

  return token;
}

async function callClaudeOAuth(
  config: LLMProvider,
  messages: Message[],
  options?: CallOptions
): Promise<LLMResponse> {
  const token = await getValidToken();

  log.debug(`Calling Claude OAuth ${config.model}`);

  // Convert messages to Claude format
  const claudeMessages = messages
    .filter((m) => m.role !== "system")
    .map((m) => ({
      role: m.role as "user" | "assistant",
      content: m.content,
    }));

  const systemMessage = messages.find((m) => m.role === "system");

  const body: Record<string, unknown> = {
    model: config.model,
    max_tokens: options?.maxTokens ?? 4096,
    system: systemMessage?.content,
    messages: claudeMessages,
  };

  if (options?.tools && options.tools.length > 0) {
    body.tools = options.tools.map((t) => ({
      name: t.name,
      description: t.description,
      input_schema: t.parameters,
    }));
  }

  const response = await fetch(CLAUDE_API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token.accessToken}`,
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const text = await response.text();
    log.error(`Claude OAuth error: ${response.status} ${text}`);
    throw new HTTPError(response.status, text);
  }

  const data = (await response.json()) as {
    content: Array<
      | { type: "text"; text: string }
      | { type: "tool_use"; id: string; name: string; input: unknown }
    >;
    usage: { input_tokens: number; output_tokens: number };
  };

  const content = data.content
    .filter((c): c is { type: "text"; text: string } => c.type === "text")
    .map((c) => c.text)
    .join("");

  const toolCalls: ToolCall[] = data.content
    .filter(
      (c): c is { type: "tool_use"; id: string; name: string; input: unknown } =>
        c.type === "tool_use"
    )
    .map((c) => ({
      id: c.id,
      name: c.name,
      arguments: c.input,
    }));

  return {
    content,
    toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
    usage: {
      promptTokens: data.usage.input_tokens,
      completionTokens: data.usage.output_tokens,
    },
    provider: "claude-oauth",
  };
}

// Register provider
providerRegistry.register("claude-oauth", callClaudeOAuth);
```

**Step 2: Update providers/index.ts to import claude-oauth**

Add to `src/agent/providers/index.ts`:

```typescript
import "./claude-oauth.js";
```

**Step 3: Verify build**

```bash
npm run build
```

**Step 4: Commit**

```bash
git add src/agent/providers/claude-oauth.ts src/agent/providers/index.ts
git commit -m "feat(providers): add claude-oauth provider"
```

---

## Task 9: Update Config Example

**Files:**
- Modify: `config.example.yaml`

**Step 1: Add claude-oauth provider example**

Add after existing providers section:

```yaml
# Option 2: OAuth (uses Claude subscription, no API key needed)
# providers:
#   - id: claude-oauth
#     model: claude-sonnet-4-5
#     priority: 1
#     apiKey: unused  # Required by schema but not used
```

**Step 2: Commit**

```bash
git add config.example.yaml
git commit -m "docs: add claude-oauth config example"
```

---

## Summary

After completing all tasks, Phase 2.5 adds:

1. **Provider Registry** - Extensible pattern for adding new LLM providers
2. **OAuth Flow** - `owliabot auth setup` for Claude subscription users
3. **Token Management** - Auto-refresh, expiry checking
4. **claude-oauth Provider** - Uses OAuth tokens instead of API keys

**To test OAuth:**

```bash
# Build
npm run build

# Setup auth
node dist/entry.js auth setup

# Check status
node dist/entry.js auth status

# Use in config.yaml
providers:
  - id: claude-oauth
    model: claude-sonnet-4-5
    priority: 1
    apiKey: unused
```
